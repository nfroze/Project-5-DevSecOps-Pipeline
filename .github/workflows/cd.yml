name: Continuous Deployment

on:
  workflow_run:
    workflows: ["Continuous Build"]
    types:
      - completed

jobs:
  deploy-and-scan:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v4

      - name: Set image tag
        run: echo "IMAGE_TAG=${{ github.sha }}" >> "$GITHUB_ENV"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v2
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: eu-west-2

      - name: Update kubeconfig for EKS
        run: aws eks update-kubeconfig --region eu-west-2 --name project5-eks-cluster

      - name: Create project5 namespace
        run: kubectl apply -f k8s/namespace.yaml

      - name: Deploy to EKS
        run: |
          kubectl apply -f k8s/deployment.yaml
          kubectl apply -f k8s/service.yaml

      - name: Set image to commit SHA
        run: |
          kubectl set image deployment/project5-deployment project5-app=nfroze/project5-app:${{ env.IMAGE_TAG }} -n project5

      - name: Install Trivy
        run: |
          sudo apt-get update
          sudo apt-get install wget apt-transport-https gnupg lsb-release -y
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy -y

      - name: Scan running container in EKS (by image)
        run: |
          IMAGE_ID="nfroze/project5-app:${{ env.IMAGE_TAG }}"
          trivy image --format json --output trivy-deploy-report.json $IMAGE_ID
        continue-on-error: true

      - name: Upload Trivy JSON Report (CD)
        uses: actions/upload-artifact@v4
        with:
          name: trivy-deploy-report
          path: trivy-deploy-report.json

      - name: Send Trivy Report to Splunk
        if: always()
        env:
          SPLUNK_HEC_URL: ${{ secrets.SPLUNK_HEC_URL }}
          SPLUNK_HEC_TOKEN: ${{ secrets.SPLUNK_HEC_TOKEN }}
        run: |
          if [ -f trivy-deploy-report.json ]; then
            curl -k "$SPLUNK_HEC_URL" \
              -H "Authorization: Splunk $SPLUNK_HEC_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"event\": $(cat trivy-deploy-report.json), \"sourcetype\": \"trivy-deploy\", \"channel\": \"cd-${GITHUB_RUN_ID}\"}"
          fi

      - name: Wait for deployment to be ready
        run: |
          echo "Waiting for deployment to be ready..."
          kubectl wait --for=condition=available --timeout=300s deployment/project5-deployment -n project5
          echo "Deployment is ready!"

      - name: Get LoadBalancer URL
        id: get-url
        run: |
          echo "Getting LoadBalancer URL..."
          # Wait for LoadBalancer to be assigned
          for i in {1..30}; do
            SERVICE_URL=$(kubectl get svc project5-service -n project5 -o jsonpath='{.status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "")
            if [ -n "$SERVICE_URL" ]; then
              break
            fi
            echo "Waiting for LoadBalancer... (attempt $i/30)"
            sleep 10
          done
          
          if [ -z "$SERVICE_URL" ]; then
            echo "LoadBalancer URL not found after 5 minutes"
            exit 1
          fi
          
          echo "SERVICE_URL=http://${SERVICE_URL}" >> $GITHUB_ENV
          echo "LoadBalancer URL: http://${SERVICE_URL}"

      - name: Run OWASP ZAP Baseline Scan
        run: |
          echo "Starting OWASP ZAP scan against ${{ env.SERVICE_URL }}"
          docker run -v $(pwd):/zap/wrk:rw \
            -t ghcr.io/zaproxy/zaproxy:stable \
            zap-baseline.py \
            -t ${{ env.SERVICE_URL }} \
            -J zap-report.json \
            -r zap-report.html \
            -I
        continue-on-error: true

      - name: Upload ZAP JSON Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zap-report-json
          path: zap-report.json

      - name: Upload ZAP HTML Report
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: zap-report-html
          path: zap-report.html

      - name: Send ZAP Report to Splunk
        if: always()
        env:
          SPLUNK_HEC_URL: ${{ secrets.SPLUNK_HEC_URL }}
          SPLUNK_HEC_TOKEN: ${{ secrets.SPLUNK_HEC_TOKEN }}
        run: |
          if [ -f zap-report.json ]; then
            echo "Sending ZAP report to Splunk..."
            curl -k "$SPLUNK_HEC_URL" \
              -H "Authorization: Splunk $SPLUNK_HEC_TOKEN" \
              -H "Content-Type: application/json" \
              -d "{\"event\": $(cat zap-report.json), \"sourcetype\": \"owasp-zap\", \"channel\": \"dast-${GITHUB_RUN_ID}\"}"
            echo "ZAP report sent to Splunk"
          fi

      - name: Check ZAP Results
        run: |
          if [ -f zap-report.json ]; then
            HIGH_ALERTS=$(jq '.site[].alerts[] | select(.riskcode == "3") | .riskcode' zap-report.json | wc -l || echo "0")
            MEDIUM_ALERTS=$(jq '.site[].alerts[] | select(.riskcode == "2") | .riskcode' zap-report.json | wc -l || echo "0")
            
            echo "DAST Scan Results:"
            echo "High Risk Alerts: $HIGH_ALERTS"
            echo "Medium Risk Alerts: $MEDIUM_ALERTS"
            
            # Only fail on high-risk alerts for demo purposes
            if [ "$HIGH_ALERTS" -gt "0" ]; then
              echo "‚ùå High-risk security issues found!"
              exit 1
            fi
          fi